/**
 * @fileOverview Firestore Security Rules for FinanceFlow application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal financial data
 * and shared access control for collaborative group expenses. Only authenticated
 * users can access data, and they can only manage data they own or have explicit
 * shared access to.
 *
 * Data Structure:
 * - /users/{userId}: User profile information.
 * - /users/{userId}/incomes/{incomeId}: Income entries for a user.
 * - /users/{userId}/expenses/{expenseId}: Expense entries for a user.
 * - /users/{userId}/categories/{categoryId}: User-defined categories.
 * - /users/{userId}/budgets/{budgetId}: User's budget entries.
 * - /groups/{groupId}: Groups for shared expenses.
 * - /groups/{groupId}/sharedExpenses/{sharedExpenseId}: Shared expenses within a group.
 * - /debts/{debtId}: Debt records between users.
 *
 * Key Security Decisions:
 * - User-owned data (under /users/{userId}) is strictly controlled by the owning user.
 * - Group data (/groups/{groupId}) is accessible only to members of the group.
 * - Listing of users is disallowed for privacy.
 * - Debt records are accessible to involved users (toUserId and fromUserId).
 *
 * Denormalization for Authorization:
 * - The 'Expense', 'Income', 'Category', and 'Budget' documents all contain a
 *   'userId' field that MUST match the parent path's {userId} to ensure data
 *   consistency and efficient rule enforcement.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description: Enforces access control for user profile data.
     * @path: /users/{userId}
     * @allow: User (create) their own profile if the userId matches their auth UID.
     * @allow: User (get) their own profile if the userId matches their auth UID.
     * @allow: User (update) their own profile if the userId matches their auth UID.
     * @allow: User (delete) their own profile if the userId matches their auth UID.
     * @deny: Any other user trying to create, read, update, or delete another user's profile.
     * @principle: Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) ;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description: Enforces access control for income entries.
     * @path: /users/{userId}/incomes/{incomeId}
     * @allow: User (create, get, list, update, delete) their own income entries.
     * @deny: Any other user trying to access another user's income entries.
     * @principle: Enforces document ownership for income entries.
     */
    match /users/{userId}/incomes/{incomeId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description: Enforces access control for expense entries.
     * @path: /users/{userId}/expenses/{expenseId}
     * @allow: User (create, get, list, update, delete) their own expense entries.
     * @deny: Any other user trying to access another user's expense entries.
     * @principle: Enforces document ownership for expense entries.
     */
    match /users/{userId}/expenses/{expenseId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description: Enforces access control for categories.
     * @path: /users/{userId}/categories/{categoryId}
     * @allow: User (create, get, list, update, delete) their own categories.
     * @deny: Any other user trying to access another user's categories.
     * @principle: Enforces document ownership for categories.
     */
    match /users/{userId}/categories/{categoryId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description: Enforces access control for budgets.
     * @path: /users/{userId}/budgets/{budgetId}
     * @allow: User (create, get, list, update, delete) their own budgets.
     * @deny: Any other user trying to access another user's budgets.
     * @principle: Enforces document ownership for budgets.
     */
    match /users/{userId}/budgets/{budgetId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description: Enforces access control for groups.
     * @path: /groups/{groupId}
     * @allow: User (create, get, list) a group if they are a member.
     * @allow: User (update, delete) a group if they are the creator.
     * @deny: Any other user trying to access the group.
     * @principle: Enforces shared access control for collaborative groups.
     */
    match /groups/{groupId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isGroupMember(groupId) {
        return isSignedIn() && resource.data.members is list && resource.data.members.hasAny([request.auth.uid]);
      }

      function isGroupCreator() {
          return isSignedIn() && resource.data.createdBy == request.auth.uid;
      }

      allow get: if isGroupMember(groupId);
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
      allow update: if isGroupCreator();
      allow delete: if isGroupCreator();
    }

    /**
     * @description: Enforces access control for shared expenses within a group.
     * @path: /groups/{groupId}/sharedExpenses/{sharedExpenseId}
     * @allow: User (create, get, list) a shared expense if they are a member of the group.
     * @deny: Any other user trying to access the shared expense.
     * @principle: Enforces shared access control for shared expenses.
     */
    match /groups/{groupId}/sharedExpenses/{sharedExpenseId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isGroupMember(groupId) {
        return isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.members is list && get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
      }
      allow get: if isGroupMember(groupId);
      allow list: if isGroupMember(groupId);
      allow create: if isGroupMember(groupId);
      allow update: if isGroupMember(groupId);
      allow delete: if isGroupMember(groupId);
    }

    /**
     * @description: Enforces access control for debts between users.
     * @path: /debts/{debtId}
     * @allow: User (create, get, list) debt if they are part of the debt, as toUserId or fromUserId.
     * @deny: Any other user trying to access the debt.
     */
    match /debts/{debtId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isDebtParticipant() {
        return isSignedIn() && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);
      }

      allow get: if isDebtParticipant();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && (request.resource.data.fromUserId == request.auth.uid || request.resource.data.toUserId == request.auth.uid);
      allow update: if isDebtParticipant();
      allow delete: if isDebtParticipant();
    }
  }
}