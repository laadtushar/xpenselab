/**
 * @fileoverview Firestore Security Rules for FinanceFlow application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal finance data,
 * and a shared-access model for group expenses.  Users can only access their
 * own income, expenses, categories, and budgets.  Groups and shared expenses
 * are accessible to members of the group.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.  Owned by the user.
 * - /users/{userId}/incomes/{incomeId}: Income entries. Owned by the user.
 * - /users/{userId}/expenses/{expenseId}: Expense entries. Owned by the user.
 * - /users/{userId}/categories/{categoryId}: Expense categories. Owned by the user.
 * - /users/{userId}/budgets/{budgetId}: Budget entries. Owned by the user.
 * - /groups/{groupId}: Group information. Accessible to group members.
 * - /groups/{groupId}/sharedExpenses/{sharedExpenseId}: Shared expenses. Accessible to group members.
 * - /debts/{debtId}: Debt information between users.
 *
 * Key Security Decisions:
 * - User listing is disallowed to protect privacy.
 * - Ambiguous cases default to strict, owner-only access.
 *
 * Denormalization for Authorization:
 * - The 'Group' entity contains a 'members' array for fast access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profile data. Only the user can read/write their own profile.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile if authenticated as 'user123'.
     * @allow (get, update, delete) User with ID 'user123' can get, update, and delete their profile if authenticated as 'user123'.
     * @deny (create) User with ID 'user123' cannot create a profile if authenticated as 'user456'.
     * @deny (get, update, delete) User with ID 'user123' cannot get, update, or delete the profile if authenticated as 'user456'.
     * @principle Enforces document ownership for writes.  Allows self-creation.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Protects income entries for a specific user. Only the user can read/write their own income entries.
     * @path /users/{userId}/incomes/{incomeId}
     * @allow (create) User with ID 'user123' can create an income entry in their own data tree if authenticated as 'user123'. The income entry's userId field must match the path.
     * @allow (get, update, delete) User with ID 'user123' can get, update, and delete an income entry in their own data tree if authenticated as 'user123'.
     * @deny (create) User with ID 'user123' cannot create an income entry in user 'user456's data tree.
     * @deny (get, update, delete) User with ID 'user123' cannot get, update, or delete an income entry in user 'user456's data tree.
     * @principle Restricts access to a user's own data tree.  Validates relational integrity between documents.
     */
    match /users/{userId}/incomes/{incomeId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
        return isOwner(userId);
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Protects expense entries for a specific user. Only the user can read/write their own expense entries.
     * @path /users/{userId}/expenses/{expenseId}
     * @allow (create) User with ID 'user123' can create an expense entry in their own data tree if authenticated as 'user123'. The expense entry's userId field must match the path.
     * @allow (get, update, delete) User with ID 'user123' can get, update, and delete an expense entry in their own data tree if authenticated as 'user123'.
     * @deny (create) User with ID 'user123' cannot create an expense entry in user 'user456's data tree.
     * @deny (get, update, delete) User with ID 'user123' cannot get, update, or delete an expense entry in user 'user456's data tree.
     * @principle Restricts access to a user's own data tree.  Validates relational integrity between documents.
     */
    match /users/{userId}/expenses/{expenseId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
        return isOwner(userId);
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Protects expense categories for a specific user. Only the user can read/write their own categories.
     * @path /users/{userId}/categories/{categoryId}
     * @allow (create) User with ID 'user123' can create a category in their own data tree if authenticated as 'user123'. The category's userId field must match the path.
     * @allow (get, update, delete) User with ID 'user123' can get, update, and delete a category in their own data tree if authenticated as 'user123'.
     * @deny (create) User with ID 'user123' cannot create a category in user 'user456's data tree.
     * @deny (get, update, delete) User with ID 'user123' cannot get, update, or delete a category in user 'user456's data tree.
     * @principle Restricts access to a user's own data tree.  Validates relational integrity between documents.
     */
    match /users/{userId}/categories/{categoryId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
        return isOwner(userId);
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Protects budget entries for a specific user. Only the user can read/write their own budgets.
     * @path /users/{userId}/budgets/{budgetId}
     * @allow (create) User with ID 'user123' can create a budget in their own data tree if authenticated as 'user123'. The budget's userId field must match the path.
     * @allow (get, update, delete) User with ID 'user123' can get, update, and delete a budget in their own data tree if authenticated as 'user123'.
     * @deny (create) User with ID 'user123' cannot create a budget in user 'user456's data tree.
     * @deny (get, update, delete) User with ID 'user123' cannot get, update, or delete a budget in user 'user456's data tree.
     * @principle Restricts access to a user's own data tree.  Validates relational integrity between documents.
     */
    match /users/{userId}/budgets/{budgetId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
        return isOwner(userId);
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Protects group information. Only members of the group can read/write group details.
     * @path /groups/{groupId}
     * @allow (create) User with ID 'user123' can create a group if they are authenticated. The createdBy field should match the user ID. The user should be added as a member.
     * @allow (get, update, delete) User with ID 'user123' can get, update, and delete a group if they are a member of the group.
     * @deny (create) User with ID 'user123' cannot create a group if they are not authenticated.
     * @deny (get, update, delete) User with ID 'user123' cannot get, update, or delete a group if they are not a member of the group.
     * @principle Enforces shared access among group members.
     */
    match /groups/{groupId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isGroupMember(groupId) {
          return isSignedIn() && request.auth.uid in resource.data.members;
      }

      allow get: if isGroupMember(groupId);
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid && request.auth.uid in request.resource.data.members;
      allow update: if isSignedIn() && isGroupMember(groupId);
      allow delete: if isSignedIn() && isGroupMember(groupId);
    }

    /**
     * @description Protects shared expenses within a group. Only members of the group can read/write shared expenses.
     * @path /groups/{groupId}/sharedExpenses/{sharedExpenseId}
     * @allow (create) User with ID 'user123' can create a shared expense within a group they are a member of.
     * @allow (get, update, delete) User with ID 'user123' can get, update, and delete a shared expense within a group they are a member of.
     * @deny (create) User with ID 'user123' cannot create a shared expense within a group they are not a member of.
     * @deny (get, update, delete) User with ID 'user123' cannot get, update, or delete a shared expense within a group they are not a member of.
     * @principle Enforces shared access among group members.
     */
    match /groups/{groupId}/sharedExpenses/{sharedExpenseId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isGroupMember(groupId) {
         return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members;
      }

      allow get: if isGroupMember(groupId);
      allow list: if false;
      allow create: if isGroupMember(groupId);
      allow update: if isGroupMember(groupId);
      allow delete: if isGroupMember(groupId);
    }

    /**
     * @description Protects debt information between users.
     * @path /debts/{debtId}
     * @allow (create, get, update, delete, list) Debt documents are currently unprotected.
     * // TODO: Add security rules for debts based on the 'fromUserId' and 'toUserId' fields.
     * @principle Placeholder for debt security.
     */
    match /debts/{debtId} {
       function isRelatedUser(debtId) {
        return request.auth.uid == resource.data.fromUserId
            || request.auth.uid == resource.data.toUserId;
      }
       function isRelatedUserRequest(debtId) {
        return request.auth.uid == request.resource.data.fromUserId
            || request.auth.uid == request.resource.data.toUserId;
      }
      allow read: if isRelatedUser(debtId);
      allow update: if isRelatedUser(debtId);
       allow delete: if isRelatedUser(debtId);
            allow create: if isRelatedUserRequest(debtId);
      allow list: if false; // disable listing for security reasons
    }
        /**
     * @description Allows listing of groups collection.
     * @path /groups
     * @allow (list) Any authenticated user can list groups.
     * @deny (list) Any unauthenticated user can list groups.
     * @principle Public listing with authentication required
     */
    match /groups {
        allow list: if request.auth != null;
    }
  }
}