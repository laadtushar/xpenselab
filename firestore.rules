/**
 * @fileoverview Firestore Security Rules for FinanceFlow application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal financial data
 * and shared access control for collaborative group expenses.
 *
 * Data Structure:
 * - User profiles are stored under `/users/{userId}`.
 * - User-specific data (incomes, expenses, categories, budgets) are stored under
 *   `/users/{userId}/[incomes|expenses|categories|budgets]/{itemId}`.
 * - Group data is stored under `/groups/{groupId}`.
 * - Shared expenses for groups are stored under `/groups/{groupId}/sharedExpenses/{expenseId}`.
 * - Debt information is stored under `/debts/{debtId}`.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data and financial records.
 * - Group expenses are shared between group members.  Rules ensure that only members of a group
 *   can access group expenses.
 * - Listing user collections is generally allowed only for the owning user.  Listing top-level
 *   collections (groups, debts) is denied to prevent information leakage.
 * - The rules do not validate the correctness or completeness of the data, focusing solely on
 *   authorization.
 *
 * Denormalization for Authorization:
 *  - Group membership: The `/groups/{groupId}` document contains a `members` array, which allows
 *    checking group membership directly without additional `get()` calls.
 *
 * Structural Segregation:
 * - Private user data is stored under user-specific subcollections. Public data or
 *   collaborative data is stored in top-level collections like `/groups`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Rules for user profiles.  Users can read and write their own profiles.
     * @path /users/{userId}
     * @allow (create) Signed-in user can create their own profile if the UID matches the document ID.
     * @allow (get, update, delete) Signed-in user can read/update/delete their own profile.
     * @deny (create) User cannot create a profile with an ID that doesn't match their own UID.
     * @deny (get, update, delete) User cannot read/update/delete another user's profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && getSelf().data != null;
      }

      function getSelf() {
        return get(/databases/$(database)/documents/users/$(userId));
      }

      allow create: if isSignedIn() && isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if false;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for income entries under a user.  Users can only access their own income entries.
     * @path /users/{userId}/incomes/{incomeId}
     * @allow (create) Signed-in user can create an income entry for themselves.
     * @allow (get, list, update, delete) Signed-in user can read/list/update/delete their own income entries.
     * @deny (create, get, list, update, delete) User cannot access another user's income entries.
     * @principle Enforces document ownership for income entries.
     */
    match /users/{userId}/incomes/{incomeId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && getSelf().data != null;
      }

      function getSelf() {
        return get(/databases/$(database)/documents/users/$(userId)/incomes/$(incomeId));
      }

      allow create: if isSignedIn() && isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for expense entries under a user.  Users can only access their own expense entries.
     * @path /users/{userId}/expenses/{expenseId}
     * @allow (create) Signed-in user can create an expense entry for themselves.
     * @allow (get, list, update, delete) Signed-in user can read/list/update/delete their own expense entries.
     * @deny (create, get, list, update, delete) User cannot access another user's expense entries.
     * @principle Enforces document ownership for expense entries.
     */
    match /users/{userId}/expenses/{expenseId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && getSelf().data != null;
      }

      function getSelf() {
        return get(/databases/$(database)/documents/users/$(userId)/expenses/$(expenseId));
      }

      allow create: if isSignedIn() && isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for categories under a user. Users can only access their own categories.
     * @path /users/{userId}/categories/{categoryId}
     * @allow (create) Signed-in user can create a category for themselves.
     * @allow (get, list, update, delete) Signed-in user can read/list/update/delete their own categories.
     * @deny (create, get, list, update, delete) User cannot access another user's categories.
     * @principle Enforces document ownership for categories.
     */
    match /users/{userId}/categories/{categoryId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && getSelf().data != null;
      }

      function getSelf() {
        return get(/databases/$(database)/documents/users/$(userId)/categories/$(categoryId));
      }

      allow create: if isSignedIn() && isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for budgets under a user.  Users can only access their own budgets.
     * @path /users/{userId}/budgets/{budgetId}
     * @allow (create) Signed-in user can create a budget for themselves.
     * @allow (get, list, update, delete) Signed-in user can read/list/update/delete their own budgets.
     * @deny (create, get, list, update, delete) User cannot access another user's budgets.
     * @principle Enforces document ownership for budgets.
     */
    match /users/{userId}/budgets/{budgetId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && getSelf().data != null;
      }

      function getSelf() {
        return get(/databases/$(database)/documents/users/$(userId)/budgets/$(budgetId));
      }

      allow create: if isSignedIn() && isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for groups.  Members can read group data; only the creator can update group members.
     * @path /groups/{groupId}
     * @allow (get) Signed-in user can read group data if they are a member.
     * @allow (create) Signed-in user can create a group.
     * @allow (update) Only group creator can update group details.
     * @allow (delete) Only group creator can delete the group.
     * @deny (list) Prevent listing all groups.
     * @deny (create, update, delete) User cannot create/update/delete a group if not authorized.
     * @principle Enforces shared access based on group membership.
     */
    match /groups/{groupId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isMember() {
        return isSignedIn() && request.auth.uid in getSelf().data.members;
      }

      function isExistingMember() {
        return isMember() && getSelf().data != null;
      }

       function isGroupCreator() {
          return isSignedIn() && getSelf().data.createdBy == request.auth.uid;
       }

       function isExistingGroupCreator() {
          return isGroupCreator() && getSelf().data != null;
       }

      function getSelf() {
        return get(/databases/$(database)/documents/groups/$(groupId));
      }

      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
      allow get: if isExistingMember();
      allow list: if false;
      allow update: if isExistingGroupCreator();
      allow delete: if isExistingGroupCreator();
    }

    /**
     * @description Rules for shared expenses within a group. Members can read and write shared expenses.
     * @path /groups/{groupId}/sharedExpenses/{expenseId}
     * @allow (create) Signed-in user can create a shared expense if they are a member of the group.
     * @allow (get, list, update, delete) Signed-in user can read/list/update/delete shared expenses if they are a member of the group.
     * @deny (create, get, list, update, delete) User cannot access shared expenses if they are not a member of the group.
     * @principle Enforces shared access based on group membership for shared expenses.
     */
    match /groups/{groupId}/sharedExpenses/{expenseId} {
      function isSignedIn() {
        return request.auth != null;
      }

     function isParentGroupMember() {
        return isSignedIn() && request.auth.uid in getParentGroup().data.members;
      }

      function getParentGroup() {
        return get(/databases/$(database)/documents/groups/$(groupId));
      }

      allow create: if isSignedIn() && isParentGroupMember();
      allow get: if isSignedIn() && isParentGroupMember();
      allow list: if isSignedIn() && isParentGroupMember();
      allow update: if isSignedIn() && isParentGroupMember();
      allow delete: if isSignedIn() && isParentGroupMember();
    }

    /**
     * @description Rules for debts between users.
     * @path /debts/{debtId}
     * @allow (create) Signed-in user can create a debt record.
     * @allow (get) Any signed-in user can get a debt record.
     * @allow (update) Only the user who created the debt record can update it.
     * @allow (delete) Only the user who created the debt record can delete it.
     * @deny (list) Prevent listing all debt records.
     * @principle Enforces creation and modification rights to the debt creator.
     */
    match /debts/{debtId} {
       function isSignedIn() {
        return request.auth != null;
      }

        function isDebtCreator() {
            return isSignedIn() && getSelf().data.createdBy == request.auth.uid;
        }

        function isExistingDebtCreator() {
            return isDebtCreator() && getSelf().data != null;
        }

      function getSelf() {
        return get(/databases/$(database)/documents/debts/$(debtId));
      }

      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
      allow get: if isSignedIn();
      allow list: if false;
      allow update: if isExistingDebtCreator();
      allow delete: if isExistingDebtCreator();
    }
  }
}