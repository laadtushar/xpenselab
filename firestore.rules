/**
 * @fileoverview Firestore Security Rules for FinanceFlow application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal finance data
 * and shared access control for collaborative group expenses.
 *
 * Data Structure:
 * - User profiles are stored under `/users/{userId}`.
 * - User-specific data (incomes, expenses, categories, budgets) are stored as
 *   subcollections under `/users/{userId}`.
 * - Group data is stored under `/groups/{groupId}`, including member lists and
 *   creator information.
 * - Shared expenses within a group are stored as subcollections under
 *   `/groups/{groupId}/sharedExpenses/{sharedExpenseId}`.
 * - Debt information is stored under `/debts/{debtId}`.
 *
 * Key Security Decisions:
 * - Users can only access their own profile data and financial records.
 * - Group access is controlled through a member list on the `/groups/{groupId}`
 *   document. Only group members can access group details and shared expenses.
 * - Listing of user documents is disallowed to prevent unauthorized data discovery.
 * - Public read access is NOT granted on any collection.
 *
 * Denormalization for Authorization:
 * - Group documents denormalize the `members` array to enable efficient
 *   authorization checks for group resources.
 *
 * Structural Segregation:
 * - User-specific data is stored under user-specific paths to maintain strict
 *   privacy and ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces access control for user profile data.
     * @path /users/{userId}
     * @allow (create) User with matching ID can create their profile.
     * @allow (get, update, delete) User with matching ID can read, update, or delete their profile.
     * @deny (create) User cannot create a profile with an ID that doesn't match their auth.uid.
     * @deny (list) Listing all users is not allowed.
     * @principle Enforces document ownership for reads and writes; self-creation for new users.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);

            match /incomes/{incomeId} {
              allow get: if isOwner(userId);
              allow list: if isOwner(userId);
              allow create: if isOwner(userId);
              allow update: if isOwner(userId);
              allow delete: if isOwner(userId);
            }

            match /expenses/{expenseId} {
              allow get: if isOwner(userId);
              allow list: if isOwner(userId);
              allow create: if isOwner(userId);
              allow update: if isOwner(userId);
              allow delete: if isOwner(userId);
            }

            match /categories/{categoryId} {
              allow get: if isOwner(userId);
              allow list: if isOwner(userId);
              allow create: if isOwner(userId);
              allow update: if isOwner(userId);
              allow delete: if isOwner(userId);
            }

            match /budgets/{budgetId} {
              allow get: if isOwner(userId);
              allow list: if isOwner(userId);
              allow create: if isOwner(userId);
              allow update: if isOwner(userId);
              allow delete: if isOwner(userId);
            }
    }

    /**
     * @description Enforces access control for group information.
     * @path /groups/{groupId}
     * @allow (create) Signed-in users can create groups. The `createdBy` field must match `auth.uid`.
     * @allow (get, list) Only members of the group can read group data.
     * @allow (update, delete) Only the group creator can update or delete the group.
     * @deny (create) Non-signed-in users cannot create groups.
     * @deny (create) Users cannot create a group with `createdBy` not matching their auth.uid.
     * @principle Enforces group membership for reads, creator-only access for updates/deletes, and validated creator on create.
     */
    match /groups/{groupId} {
      function isMember(groupId) {
        return request.auth.uid in resource.data.members;
      }
      function isGroupCreator(groupId) {
        return request.auth.uid == resource.data.createdBy;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isMember(groupId);
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
      allow update: if isGroupCreator(groupId);
      allow delete: if isGroupCreator(groupId);

          match /sharedExpenses/{sharedExpenseId} {
            function isMember(groupId) {
              return request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members;
            }
            function isPayer(groupId, sharedExpenseId) {
              return request.auth.uid == get(/databases/$(database)/documents/groups/$(groupId)/sharedExpenses/$(sharedExpenseId)).data.paidBy;
            }
            function isSignedIn() {
              return request.auth != null;
            }

            allow get: if isMember(groupId);
            allow list: if isMember(groupId);
            allow create: if isMember(groupId) ;
            allow update: if isMember(groupId) && isPayer(groupId, sharedExpenseId);
            allow delete: if isMember(groupId) && isPayer(groupId, sharedExpenseId);
          }
    }

    /**
     * @description Enforces access control for debt information.
     * @path /debts/{debtId}
     * @allow (create) Only the `fromUserId` can create a debt. The `fromUserId` field must match `auth.uid`.
     * @allow (get) Only the `fromUserId` or `toUserId` can read debt information.
     * @allow (list) Not allowed, as debt information should not be generally discoverable.
     * @allow (update) Only the `toUserId` can update the `settled` flag. Other fields are immutable.
     * @allow (delete) Never allowed. Debts should not be deleted, but rather marked as `settled`.
     * @deny (create) Users cannot create a debt with a `fromUserId` not matching their `auth.uid`.
     * @deny (update) The `fromUserId` or `toUserId` cannot be changed after creation.
     * @principle Enforces participation-based reads, `fromUserId`-only creates, and `toUserId`-only settle.
     */
    match /debts/{debtId} {
      function isParticipant(debtId) {
        return request.auth.uid == resource.data.fromUserId || request.auth.uid == resource.data.toUserId;
      }
      function isPayer(debtId) {
        return request.auth.uid == resource.data.fromUserId;
      }
      function isPayee(debtId) {
        return request.auth.uid == resource.data.toUserId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if getAfter(isParticipant(debtId));
      allow list: if false;
      allow create: if request.auth.uid == request.resource.data.fromUserId;
      allow update: if request.auth.uid == resource.data.toUserId;
      allow delete: if false;
    }
  }
}