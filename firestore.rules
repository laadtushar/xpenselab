/**
 * @file Firebase Security Rules for FinanceFlow
 * @corePhilosophy This ruleset enforces a strict user-ownership model for personal financial data,
 *   and a shared-access model for collaborative expense splitting features. It prioritizes
 *   authorization independence and avoids complex queries in rules for optimal performance.
 * @dataStructure
 *   - /users/{userId}: Stores user profile data.
 *   - /users/{userId}/incomes/{incomeId}: Stores income entries for a user.
 *   - /users/{userId}/expenses/{expenseId}: Stores expense entries for a user.
 *   - /users/{userId}/categories/{categoryId}: Stores categories for a user.
 *   - /users/{userId}/budgets/{budgetId}: Stores budget entries for a user.
 *   - /groups/{groupId}: Stores group information for shared expenses.
 *   - /groups/{groupId}/sharedExpenses/{sharedExpenseId}: Stores shared expense data for a group.
 *   - /debts/{debtId}: Stores debt information between two users.
 * @keySecurityDecisions
 *   - User data is strictly controlled by the owning user.
 *   - Listing of users is disallowed.
 *   - Groups and SharedExpenses are accessible to group members.
 *   - Debts are accessible to the users involved.
 *   - Data validation is limited to authorization-critical fields for prototyping flexibility.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' can read their profile. request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' can update their profile. request.auth.uid == 'user123'
     * @deny (create) User with ID 'user456' attempts to create a profile with ID 'user123'.
     * @deny (get) User with ID 'user456' attempts to read the profile of 'user123'.
     * @deny (update) User with ID 'user456' attempts to update the profile of 'user123'.
     * @principle Enforces document ownership, ensuring only the authenticated user can access their own profile.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages income entries for a specific user.
     * @path /users/{userId}/incomes/{incomeId}
     * @allow (create) User with ID 'user123' can create an income entry: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' can read their income entry. request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' can update their income entry. request.auth.uid == 'user123'
     * @deny (create) User with ID 'user456' attempts to create an income entry for 'user123'.
     * @deny (get) User with ID 'user456' attempts to read the income entry of 'user123'.
     * @deny (update) User with ID 'user456' attempts to update the income entry of 'user123'.
     * @principle Enforces document ownership, ensuring only the authenticated user can access their own income data.
     */
    match /users/{userId}/incomes/{incomeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages expense entries for a specific user.
     * @path /users/{userId}/expenses/{expenseId}
     * @allow (create) User with ID 'user123' can create an expense entry: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' can read their expense entry. request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' can update their expense entry. request.auth.uid == 'user123'
     * @deny (create) User with ID 'user456' attempts to create an expense entry for 'user123'.
     * @deny (get) User with ID 'user456' attempts to read the expense entry of 'user123'.
     * @deny (update) User with ID 'user456' attempts to update the expense entry of 'user123'.
     * @principle Enforces document ownership, ensuring only the authenticated user can access their own expense data.
     */
    match /users/{userId}/expenses/{expenseId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages categories for a specific user.
     * @path /users/{userId}/categories/{categoryId}
     * @allow (create) User with ID 'user123' can create a category: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' can read their category. request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' can update their category. request.auth.uid == 'user123'
     * @deny (create) User with ID 'user456' attempts to create a category for 'user123'.
     * @deny (get) User with ID 'user456' attempts to read the category of 'user123'.
     * @deny (update) User with ID 'user456' attempts to update the category of 'user123'.
     * @principle Enforces document ownership, ensuring only the authenticated user can access their own category data.
     */
    match /users/{userId}/categories/{categoryId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages budget entries for a specific user.
     * @path /users/{userId}/budgets/{budgetId}
     * @allow (create) User with ID 'user123' can create a budget: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' can read their budget. request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' can update their budget. request.auth.uid == 'user123'
     * @deny (create) User with ID 'user456' attempts to create a budget for 'user123'.
     * @deny (get) User with ID 'user456' attempts to read the budget of 'user123'.
     * @deny (update) User with ID 'user456' attempts to update the budget of 'user123'.
     * @principle Enforces document ownership, ensuring only the authenticated user can access their own budget data.
     */
    match /users/{userId}/budgets/{budgetId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages group information for shared expenses.
     * @path /groups/{groupId}
     * @allow (create) User with ID 'user123' can create a group if they are the creator.
     * @allow (get) User with ID 'user123' can read a group if they are a member.
     * @allow (update) User with ID 'user123' can update a group if they are a member.
     * @deny (create) User with ID 'user456' attempts to create a group without being the creator.
     * @deny (get) User with ID 'user456' attempts to read a group they are not a member of.
     * @deny (update) User with ID 'user456' attempts to update a group they are not a member of.
     * @principle Restricts access to group data to group members.
     */
    match /groups/{groupId} {
      allow get: if isSignedIn() && isGroupMember(groupId);
      allow list: if false; // Listing groups is not permitted.
      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
      allow update: if isSignedIn() && isExistingGroupMember(groupId);
      allow delete: if isSignedIn() && isExistingGroupMember(groupId);
    }

    /**
     * @description Manages shared expense data for a group.
     * @path /groups/{groupId}/sharedExpenses/{sharedExpenseId}
     * @allow (create) User with ID 'user123' can create a shared expense if they are a member of the group.
     * @allow (get) User with ID 'user123' can read a shared expense if they are a member of the group.
     * @allow (update) User with ID 'user123' can update a shared expense if they are a member of the group.
     * @deny (create) User with ID 'user456' attempts to create a shared expense without being a member of the group.
     * @deny (get) User with ID 'user456' attempts to read a shared expense they are not a member of the group.
     * @deny (update) User with ID 'user456' attempts to update a shared expense they are not a member of the group.
     * @principle Restricts access to shared expense data to group members.
     */
    match /groups/{groupId}/sharedExpenses/{sharedExpenseId} {
      allow get: if isSignedIn() && isGroupMember(groupId);
      allow list: if isSignedIn() && isGroupMember(groupId);
      allow create: if isSignedIn() && isGroupMember(groupId);
      allow update: if isSignedIn() && isExistingGroupMember(groupId);
      allow delete: if isSignedIn() && isExistingGroupMember(groupId);
    }

    /**
     * @description Manages debt information between two users.
     * @path /debts/{debtId}
     * @allow (create) User with ID 'user123' can create a debt involving themself.
     * @allow (get) User with ID 'user123' can read a debt involving themself.
     * @allow (update) User with ID 'user123' can update a debt involving themself.
     * @deny (create) User with ID 'user456' attempts to create a debt not involving themself.
     * @deny (get) User with ID 'user456' attempts to read a debt not involving themself.
     * @deny (update) User with ID 'user456' attempts to update a debt not involving themself.
     * @principle Restricts access to debt data to the users involved.
     */
    match /debts/{debtId} {
      allow get: if isSignedIn() && isDebtInvolved(resource.data.fromUserId, resource.data.toUserId);
      allow list: if isSignedIn() && isDebtInvolved(resource.data.fromUserId, resource.data.toUserId);
      allow create: if isSignedIn() && (request.resource.data.fromUserId == request.auth.uid || request.resource.data.toUserId == request.auth.uid);
      allow update: if isSignedIn() && isExistingDebtInvolved(resource.data.fromUserId, resource.data.toUserId);
      allow delete: if isSignedIn() && isExistingDebtInvolved(resource.data.fromUserId, resource.data.toUserId);
    }

    // --- Helper functions ---

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isGroupMember(groupId) {
      return exists(/databases/$(database)/documents/groups/$(groupId)) && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members;
    }

    function isExistingGroupMember(groupId) {
        return isGroupMember(groupId) && resource != null;
    }

    function isDebtInvolved(fromUserId, toUserId) {
      return isSignedIn() && (request.auth.uid == fromUserId || request.auth.uid == toUserId);
    }

    function isExistingDebtInvolved(fromUserId, toUserId) {
      return isDebtInvolved(fromUserId, toUserId) && resource != null;
    }
  }
}