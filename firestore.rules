/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for personal finance data,
 *              while allowing shared access to group-related data.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information. Only the authenticated user can
 *                     read or write their own profile.
 * - /users/{userId}/incomes/{incomeId}: Stores income entries. Only the owning user
 *                                       can manage their income records.
 * - /users/{userId}/expenses/{expenseId}: Stores expense entries. Only the owning user
 *                                         can manage their expense records.
 * - /users/{userId}/categories/{categoryId}: Stores user-defined categories. Only the
 *                                            owning user can manage their categories.
 * - /users/{userId}/budgets/{budgetId}: Stores budget information. Only the owning user
 *                                      can manage their budget records.
 * - /groups/{groupId}: Stores group information. Access is controlled via the 'members'
 *                      field, allowing members to read and write group details.
 * - /groups/{groupId}/sharedExpenses/{expenseId}: Stores shared expenses for a group. Access
 *                                                 is controlled by group membership.
 * - /debts/{debtId}: Stores debt information between users.  Write access is restricted
 *                    to the user who created the debt.
 *
 * Key Security Decisions:
 * - User listing is explicitly denied for privacy.
 * - Data validation is relaxed in this prototyping phase to allow for rapid schema iteration.
 * - All write operations require authentication.
 *
 * Denormalization for Authorization:
 * - Group and SharedExpense documents should contain a list of member UIDs to efficiently
 *   control access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data.
     * @path /users/{userId}
     * @allow (create, update, get, delete) if the authenticated user's UID matches the userId.
     * @deny (create, update, delete) if the authenticated user's UID does not match the userId.
     * @deny list
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to income entries for a specific user.
     * @path /users/{userId}/incomes/{incomeId}
     * @allow (create, update, get, delete) if the authenticated user's UID matches the userId.
     * @deny (create, update, delete) if the authenticated user's UID does not match the userId.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/incomes/{incomeId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to expense entries for a specific user.
     * @path /users/{userId}/expenses/{expenseId}
     * @allow (create, update, get, delete) if the authenticated user's UID matches the userId.
     * @deny (create, update, delete) if the authenticated user's UID does not match the userId.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/expenses/{expenseId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to user-specific categories.
     * @path /users/{userId}/categories/{categoryId}
     * @allow (create, update, get, delete) if the authenticated user's UID matches the userId.
     * @deny (create, update, delete) if the authenticated user's UID does not match the userId.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/categories/{categoryId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to budget entries for a specific user.
     * @path /users/{userId}/budgets/{budgetId}
     * @allow (create, update, get, delete) if the authenticated user's UID matches the userId.
     * @deny (create, update, delete) if the authenticated user's UID does not match the userId.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/budgets/{budgetId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to group information.
     * @path /groups/{groupId}
     * @allow (get, list) if the authenticated user is a member of the group.
     * @allow (create, update, delete) if the authenticated user is the creator of the group.
     * @deny (create, update, delete) if the authenticated user is not the creator of the group.
     * @principle Enforces shared access for group members.
     */
    match /groups/{groupId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isMember(groupId) {
          return isSignedIn() && request.auth.uid in resource.data.members;
      }

      function isCreator() {
        return request.auth != null && request.auth.uid == resource.data.createdBy;
      }

      allow get: if isMember(groupId);
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if isMember(groupId);
      allow delete: if isSignedIn() && isCreator();
    }

    /**
     * @description Controls access to shared expenses for a group.
     * @path /groups/{groupId}/sharedExpenses/{expenseId}
     * @allow (get, list) if the authenticated user is a member of the group.
     * @allow (create, update, delete) if the authenticated user is a member of the group.
     * @deny (create, update, delete) if the authenticated user is not a member of the group.
     * @principle Enforces shared access for group members.
     */
    match /groups/{groupId}/sharedExpenses/{expenseId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isMember(groupId) {
        return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members;
      }

      allow get: if isMember(groupId);
      allow list: if false;
      allow create: if isMember(groupId);
      allow update: if isMember(groupId);
      allow delete: if isMember(groupId);
    }

    /**
     * @description Controls access to debt information between two users.
     * @path /debts/{debtId}
     * @allow (get, list) if the authenticated user is either the sender or receiver of the debt.
     * @allow (create) if the authenticated user is creating the debt.
     * @allow (update, delete) if the authenticated user created the debt
     * @deny (create, update, delete) if the authenticated user is not creating the debt
     * @principle Enforces access based on involvement in the debt.
     */
    match /debts/{debtId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function canViewDebt() {
        return isSignedIn() && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);
      }

      function isCreator() {
          return isSignedIn() && request.auth.uid == resource.data.fromUserId;
      }
      
      allow get: if canViewDebt();
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.fromUserId;
      allow update: if isSignedIn() && isCreator();
      allow delete: if isSignedIn() && isCreator();
    }
  }
}