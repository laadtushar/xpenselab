/**
 * @fileOverview Firestore Security Rules for FinanceFlow.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data and group-based authorization for shared expenses.
 * Users can only access their own data (incomes, expenses, categories, budgets) and data explicitly shared with them through groups.
 *
 * Data Structure:
 * - /users/{userId}: Stores individual user profiles.
 * - /users/{userId}/incomes/{incomeId}: Stores income entries for each user.
 * - /users/{userId}/expenses/{expenseId}: Stores expense entries for each user.
 * - /users/{userId}/categories/{categoryId}: Stores custom categories for each user.
 * - /users/{userId}/budgets/{budgetId}: Stores budget information for each user.
 * - /groups/{groupId}: Stores group information, including members.
 * - /groups/{groupId}/sharedExpenses/{expenseId}: Stores shared expenses for a group.
 * - /debts/{debtId}: Stores debt information between users.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - All data under a user's path (/users/{userId}/*) is strictly controlled by the user.
 * - Groups and shared expenses are secured using a shared access pattern.
 * - Debts can be created by either the creditor or the debtor.
 *
 * Denormalization for Authorization:
 * - Group documents denormalize the list of member UIDs in the `members` array.  This allows checking group membership without additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data.
     * @path /users/{userId}
     * @allow (create) User with matching auth UID can create their own profile.
     * @deny (create) User attempts to create a profile with a different UID.
     * @allow (get, list, update, delete) User with matching auth UID can read, update, and delete their own profile.
     * @deny (get, list, update, delete) User attempts to access another user's profile.
     * @principle Enforces document ownership and allows self-creation.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to income entries for a specific user.
     * @path /users/{userId}/incomes/{incomeId}
     * @allow (create, get, list, update, delete) User with matching auth UID can manage their own income entries.
     * @deny (create, get, list, update, delete) User attempts to access another user's income entries.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/incomes/{incomeId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to expense entries for a specific user.
     * @path /users/{userId}/expenses/{expenseId}
     * @allow (create, get, list, update, delete) User with matching auth UID can manage their own expense entries.
     * @deny (create, get, list, update, delete) User attempts to access another user's expense entries.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/expenses/{expenseId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to user-specific expense categories.
     * @path /users/{userId}/categories/{categoryId}
     * @allow (create, get, list, update, delete) User with matching auth UID can manage their own expense categories.
     * @deny (create, get, list, update, delete) User attempts to access another user's expense categories.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/categories/{categoryId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to budget entries for a specific user.
     * @path /users/{userId}/budgets/{budgetId}
     * @allow (create, get, list, update, delete) User with matching auth UID can manage their own budget entries.
     * @deny (create, get, list, update, delete) User attempts to access another user's budget entries.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/budgets/{budgetId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to group information.
     * @path /groups/{groupId}
     * @allow (get, list) Any signed-in user can list and get groups.
     * @allow (create) Any signed-in user can create a group.
     * @allow (update, delete) Only group members can update and delete group.
     * @deny (update, delete) Non-group members cannot update and delete group.
     * @principle Enforces shared access and allows anyone to create a group.
     */
    match /groups/{groupId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isMember(groupId) {
        return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isMember(groupId);
      allow delete: if isSignedIn() && isMember(groupId);
    }

    /**
     * @description Controls access to shared expenses within a group.
     * @path /groups/{groupId}/sharedExpenses/{expenseId}
     * @allow (get, list) Any signed-in user can list and get shared expenses.
     * @allow (create, update, delete) Only group members can create, update and delete shared expenses.
     * @deny (create, update, delete) Non-group members cannot create, update and delete shared expenses.
     * @principle Enforces shared access.
     */
    match /groups/{groupId}/sharedExpenses/{expenseId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isMember(groupId) {
        return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && isMember(groupId);
      allow update: if isSignedIn() && isMember(groupId);
      allow delete: if isSignedIn() && isMember(groupId);
    }

    /**
     * @description Controls access to debt information between users.
     * @path /debts/{debtId}
     * @allow (get, list) Any signed-in user can list and get debts.
     * @allow (create) Any signed-in user can create debt.
     * @allow (update, delete) Only either toUserId or fromUserId can update and delete debt.
     * @deny (update, delete) None of toUserId and fromUserId can update and delete debt.
     * @principle Enforces shared access.
     */
    match /debts/{debtId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isRelatedUser(debtId) {
        return isSignedIn() && (request.auth.uid == get(/databases/$(database)/documents/debts/$(debtId)).data.toUserId || request.auth.uid == get(/databases/$(database)/documents/debts/$(debtId)).data.fromUserId)
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isRelatedUser(debtId);
      allow delete: if isSignedIn() && isRelatedUser(debtId);
    }
  }
}