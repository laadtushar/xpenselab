/**
 * @fileOverview Firestore Security Rules for FinanceFlow.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal financial data
 * (incomes, expenses, budgets, categories), ensuring that only the authenticated
 * user can create, read, update, or delete their own data. Shared financial data
 * (groups, shared expenses, debts) uses a shared access model, where group members
 * can access group-related data.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.
 * - /users/{userId}/incomes/{incomeId}: Stores income entries for a specific user.
 * - /users/{userId}/expenses/{expenseId}: Stores expense entries for a specific user.
 * - /users/{userId}/categories/{categoryId}: Stores categories for a specific user.
 * - /users/{userId}/budgets/{budgetId}: Stores budget entries for a specific user.
 * - /users/{userId}/recurringTransactions/{recurringTransactionId}: Stores recurring transactions.
 * - /users/{userId}/financialInsights/{insightId}: Stores AI-generated insights.
 * - /users/{userId}/loans/{loanId}: Stores structured loans for a user.
 * - /users/{userId}/loans/{loanId}/repayments/{repaymentId}: Stores repayments for a loan.
 * - /groups/{groupId}: Stores group information for shared expenses.
 * - /groups/{groupId}/sharedExpenses/{expenseId}: Stores individual shared expenses.
 * - /debts/{debtId}: Stores debt information between users.
 *
 * Key Security Decisions:
 * - Users can only access their own profile data.
 * - Users can only access income, expense, category, budget, and loan data associated with their user ID.
 * - Groups and shared expenses are accessible to group members only.
 * - Debts are accessible only to participants (fromUserId, toUserId).
 * - List operations require client-side query filtering for security.
 * - Critical fields are validated on create/update operations.
 */

rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create, read, update, delete) - User with matching {userId} can manage their profile.
     * @validation Ensures userId field matches document path.
     */
    match /users/{userId} {
      allow read, delete: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
      allow update: if request.auth.uid == userId;
    }

    /**
     * @description Controls access to income entries for a specific user.
     * @path /users/{userId}/incomes/{incomeId}
     * @validation Ensures userId field matches and exists in document.
     */
    match /users/{userId}/incomes/{incomeId} {
      allow read, delete: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
      allow update: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
    }

    match /users/{userId}/incomes {
      allow list: if request.auth.uid == userId;
    }

    /**
     * @description Controls access to expense entries for a specific user.
     * @path /users/{userId}/expenses/{expenseId}
     * @validation Ensures userId field matches and exists in document.
     */
    match /users/{userId}/expenses/{expenseId} {
      allow read, delete: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
      allow update: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
    }

    match /users/{userId}/expenses {
      allow list: if request.auth.uid == userId;
    }

    /**
     * @description Controls access to category entries for a specific user.
     * @path /users/{userId}/categories/{categoryId}
     * @validation Ensures userId field matches and exists in document.
     */
    match /users/{userId}/categories/{categoryId} {
      allow read, delete: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
      allow update: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
    }

    match /users/{userId}/categories {
      allow list: if request.auth.uid == userId;
    }

    /**
     * @description Controls access to recurring transactions for a specific user.
     * @validation Ensures userId field matches and exists in document.
     */
    match /users/{userId}/recurringTransactions/{recurringTransactionId} {
      allow read, delete: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
      allow update: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
    }

    match /users/{userId}/recurringTransactions {
      allow list: if request.auth.uid == userId;
    }

    /**
     * @description Controls access to financial insights for a specific user.
     * @note Insights are immutable after creation (no updates allowed).
     */
    match /users/{userId}/financialInsights/{insightId} {
      allow read, delete: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
      allow update: if false; // Insights are immutable
    }

    match /users/{userId}/financialInsights {
      allow list: if request.auth.uid == userId;
    }

    /**
     * @description Controls access to loan and repayment entries for a specific user.
     * @validation Ensures userId field matches and exists in document.
     */
    match /users/{userId}/loans/{loanId} {
      allow read, delete: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
      allow update: if request.auth.uid == userId 
        && request.resource.data.userId == userId;

      match /repayments/{repaymentId} {
        allow read, delete: if request.auth.uid == userId;
        allow create: if request.auth.uid == userId;
        allow update: if request.auth.uid == userId;
      }

      match /repayments {
        allow list: if request.auth.uid == userId;
      }
    }

    match /users/{userId}/loans {
      allow list: if request.auth.uid == userId;
    }

    /**
     * @description Controls access to budget entries for a specific user.
     * @validation Ensures userId field matches and exists in document.
     */
    match /users/{userId}/budgets/{budgetId} {
      allow read, delete: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
      allow update: if request.auth.uid == userId 
        && request.resource.data.userId == userId;
    }

    match /users/{userId}/budgets {
      allow list: if request.auth.uid == userId;
    }

    /**
     * @description Controls access to group documents.
     * @path /groups/{groupId}
     * @allow (create) - Any authenticated user can create a group if they set themselves as creator and member.
     * @allow (get) - Only group members can read group details.
     * @allow (update) - Only group members can update the group.
     * @allow (delete) - Only the group creator can delete the group.
     * @note Use client-side queries: .where('members', 'array-contains', currentUserId)
     */
    match /groups/{groupId} {
      allow get: if isSignedIn() && isGroupMember(groupId);
      allow create: if isSignedIn() 
        && request.resource.data.createdBy == request.auth.uid
        && request.auth.uid in request.resource.data.members;
      allow update: if isSignedIn() 
        && isGroupMember(groupId);
      allow delete: if isSignedIn() 
        && resource.data.createdBy == request.auth.uid;
    }

    /**
     * @note List operations blocked - use array-contains queries on client side
     * Example: db.collection('groups').where('members', 'array-contains', currentUserId)
     */
    match /groups {
      allow list: if false;
    }

    /**
     * @description Controls access to shared expense documents within a group.
     * @path /groups/{groupId}/sharedExpenses/{expenseId}
     * @allow (create) - Only group members can create shared expenses they paid for.
     * @allow (get) - Only group members can read shared expenses.
     * @allow (update, delete) - Only the user who paid can update or delete the expense.
     * @validation Ensures paidBy matches authenticated user and groupId is correct.
     */
    match /groups/{groupId}/sharedExpenses/{expenseId} {
      allow get: if isSignedIn() && isGroupMember(groupId);
      allow create: if isSignedIn() 
        && isGroupMember(groupId) 
        && request.resource.data.groupId == groupId
        && request.resource.data.paidBy == request.auth.uid;
      allow update: if isSignedIn() 
        && isGroupMember(groupId) 
        && resource.data.paidBy == request.auth.uid
        && request.resource.data.paidBy == request.auth.uid;
      allow delete: if isSignedIn() 
        && isGroupMember(groupId) 
        && resource.data.paidBy == request.auth.uid;
    }

    match /groups/{groupId}/sharedExpenses {
      allow list: if isSignedIn() && isGroupMember(groupId);
    }

    /**
     * @description Controls access to debt documents.
     * @path /debts/{debtId}
     * @allow (get) - Only participants (fromUserId or toUserId) can read.
     * @allow (create) - Any authenticated user can create a debt if they're a participant.
     * @allow (update, delete) - Only participants can modify the debt.
     * @note Use client-side queries for listing debts:
     *   - .where('fromUserId', '==', currentUserId)
     *   - .where('toUserId', '==', currentUserId)
     */
    match /debts/{debtId} {
      allow get: if isSignedIn() && (
        request.auth.uid == resource.data.fromUserId 
        || request.auth.uid == resource.data.toUserId
      );
      allow create: if isSignedIn() 
        && (request.auth.uid == request.resource.data.fromUserId 
          || request.auth.uid == request.resource.data.toUserId)
        && request.resource.data.fromUserId != request.resource.data.toUserId;
      allow update: if isSignedIn() && (
        request.auth.uid == resource.data.fromUserId 
        || request.auth.uid == resource.data.toUserId
      );
      allow delete: if isSignedIn() && (
        request.auth.uid == resource.data.fromUserId 
        || request.auth.uid == resource.data.toUserId
      );
    }

    /**
     * @note List operations blocked - use filtered queries on client side
     * Example: db.collection('debts').where('fromUserId', '==', currentUserId)
     * Example: db.collection('debts').where('toUserId', '==', currentUserId)
     */
    match /debts {
      allow list: if false;
    }

    // ========== Helper Functions ==========

    /**
     * @function isSignedIn
     * @returns {boolean} True if user is authenticated
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @function isOwner
     * @param {string} userId - The user ID to check ownership against
     * @returns {boolean} True if authenticated user matches userId
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @function isGroupMember
     * @param {string} groupId - The group ID to check membership
     * @returns {boolean} True if authenticated user is in the group's members array
     * @note This performs a document read and counts against quota
     */
    function isGroupMember(groupId) {
      return request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members;
    }
  }
}
    