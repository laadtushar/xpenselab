/**
 * @fileOverview Firestore Security Rules for FinanceFlow application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal financial data
 * (incomes, expenses, categories, budgets). Users can only access and modify their
 * own data. Groups and shared expenses use a shared access model, where members
 * of a group can access group-related data. Debts are generally visible, but their
 * creation is restricted to authenticated users.
 *
 * Data Structure:
 * - /users/{userId}: User profile data.
 * - /users/{userId}/incomes: Income entries for a specific user.
 * - /users/{userId}/expenses: Expense entries for a specific user.
 * - /users/{userId}/categories: User-specific expense categories.
 * - /users/{userId}/budgets: Budget entries for a specific user.
 * - /groups: Group information, including members.
 * - /groups/{groupId}/sharedExpenses: Shared expenses for a group.
 * - /debts: Debt information between two users.
 *
 * Key Security Decisions:
 * - Users can only read, create, update, or delete their own income, expense,
 *   category, and budget data.
 * - Listing of debts is allowed for any signed-in user to facilitate discovery,
 *   but creation is restricted to signed-in users.
 * - The rules do NOT currently enforce the precise schema of the data, allowing
 *   for rapid prototyping. However, they do enforce relationship integrity.
 *
 * Denormalization for Authorization:
 * - The current ruleset does not require denormalization. Ownership is validated
 *   via the `userId` field on subcollections under `/users/{userId}`. Group
 *   membership is validated via the `members` array on the `/groups/{groupId}`
 *   document. Debt creation uses the `createdBy` field.
 *
 * Structural Segregation:
 * - The application uses user subcollections (e.g., /users/{userId}/incomes) to
 *   segregate private user data. There is no need to distinguish between public
 *   and private data within a single collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows access to user profile data.
     * @path /users/{userId}
     * @allow (create) User with matching ID can create their profile.
     * @allow (get, update, delete) User with matching ID can read, update, and delete their profile.
     * @deny (create) User cannot create a profile with a mismatched ID.
     * @principle Enforces document ownership.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows access to income entries for a specific user.
     * @path /users/{userId}/incomes
     * @allow (create) User with matching ID can create income entries.
     * @allow (get, list, update, delete) User with matching ID can read, list, update, and delete their income entries.
     * @deny (create) User cannot create income entries with a mismatched ID.
     * @principle Enforces document ownership.
     */
    match /users/{userId}/incomes/{incomeId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows access to expense entries for a specific user.
     * @path /users/{userId}/expenses
     * @allow (create) User with matching ID can create expense entries.
     * @allow (get, list, update, delete) User with matching ID can read, list, update, and delete their expense entries.
     * @deny (create) User cannot create expense entries with a mismatched ID.
     * @principle Enforces document ownership.
     */
    match /users/{userId}/expenses/{expenseId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows access to user-specific expense categories.
     * @path /users/{userId}/categories
     * @allow (create) User with matching ID can create categories.
     * @allow (get, list, update, delete) User with matching ID can read, list, update, and delete their categories.
     * @deny (create) User cannot create categories with a mismatched ID.
     * @principle Enforces document ownership.
     */
    match /users/{userId}/categories/{categoryId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows access to budget entries for a specific user.
     * @path /users/{userId}/budgets
     * @allow (create) User with matching ID can create budget entries.
     * @allow (get, list, update, delete) User with matching ID can read, list, update, and delete their budget entries.
     * @deny (create) User cannot create budget entries with a mismatched ID.
     * @principle Enforces document ownership.
     */
    match /users/{userId}/budgets/{budgetId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows access to group information, including members.
     * @path /groups
     * @allow (create) Signed-in user can create a group. `createdBy` field must match their uid.
     * @allow (get, list) Any signed-in user can read and list groups.
     * @allow (update, delete) Only the creator can update and delete.
     * @principle Enforces group ownership and shared access.
     */
    match /groups/{groupId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isGroupMember(groupId) {
        return isSignedIn() && request.auth.uid in resource.data.members;
      }
      function isGroupCreator(groupId) {
        return isSignedIn() && resource.data.createdBy == request.auth.uid;
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
      allow update: if isGroupCreator(groupId);
      allow delete: if isGroupCreator(groupId);
    }

    /**
     * @description Allows access to shared expenses for a group.
     * @path /groups/{groupId}/sharedExpenses
     * @allow (create) Group members can create shared expenses. `paidBy` field must match their uid.
     * @allow (get, list) Group members can read and list shared expenses.
     * @allow (update, delete) Only the user who paid for the expense can update and delete.
     */
    match /groups/{groupId}/sharedExpenses/{sharedExpenseId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isGroupMember(groupId) {
          return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members;
        }

        function isExpensePayer(sharedExpenseId) {
            return isSignedIn() && resource.data.paidBy == request.auth.uid;
        }

        allow get: if isGroupMember(groupId);
        allow list: if isGroupMember(groupId);
        allow create: if isGroupMember(groupId) && request.resource.data.paidBy == request.auth.uid;
        allow update: if isGroupMember(groupId) && isExpensePayer(sharedExpenseId);
        allow delete: if isGroupMember(groupId) && isExpensePayer(sharedExpenseId);
    }

    /**
     * @description Allows access to debt information between two users.
     * @path /debts
     * @allow (create) Any signed-in user can create a debt.
     * @allow (get, list) Any signed-in user can read and list debts.
     *  The user is added to the debt during creation in the app (either as from or to user).
     * @allow (update) No updates allowed on debt as settlement is the only change.
     */
    match /debts/{debtId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isInvolvedInDebt(debtId) {
        return isSignedIn() && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);
      }

      allow get: if isInvolvedInDebt(debtId);
      allow list: if isSignedIn();
      allow create: if isSignedIn() && (request.resource.data.fromUserId == request.auth.uid || request.resource.data.toUserId == request.auth.uid);
      allow update: if false; // Disable update, creation sets the required debt record.
      allow delete: if false;
    }
  }
}