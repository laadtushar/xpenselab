
/**
 * @fileOverview Firestore Security Rules for FinanceFlow.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal financial data
 * (incomes, expenses, budgets, categories), ensuring that only the authenticated
 * user can create, read, update, or delete their own data. Shared financial data
 * (groups, shared expenses, debts) uses a shared access model, where group members
 * can access group-related data.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.
 * - /users/{userId}/incomes/{incomeId}: Stores income entries for a specific user.
 * - /users/{userId}/expenses/{expenseId}: Stores expense entries for a specific user.
 * - /users/{userId}/categories/{categoryId}: Stores categories for a specific user.
 * - /users/{userId}/budgets/{budgetId}: Stores budget entries for a specific user.
 * - /users/{userId}/recurringTransactions/{recurringTransactionId}: Stores recurring transactions.
 * - /users/{userId}/financialInsights/{insightId}: Stores AI-generated insights.
 * - /users/{userId}/loans/{loanId}: Stores structured loans for a user.
 * - /users/{userId}/loans/{loanId}/repayments/{repaymentId}: Stores repayments for a loan.
 * - /groups/{groupId}: Stores group information for shared expenses.
 * - /groups/{groupId}/sharedExpenses/{expenseId}: Stores individual shared expenses.
 * - /debts/{debtId}: Stores debt information between users.
 *
 * Key Security Decisions:
 * - Users can only access their own profile data.
 * - Users can only access income, expense, category, budget, and loan data associated with their user ID.
 * - Groups and shared expenses are accessible to group members.
 * - Debts are accessible to participants.
 * - Data validation is relaxed in this prototype phase, focusing on authorization.
 *
 * Denormalization for Authorization:
 * - Incomes, expenses, categories and budgets documents all require the `userId` field for
 *   authorization.
 * - SharedExpenses documents require `groupId` and the `splits` array to determine authorized users.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     */
    match /users/{userId} {
      allow read, update, delete, create: if request.auth.uid == userId;
    }

    /**
     * @description Controls access to all user-specific subcollections.
     * Grants list and write access to the owner of the data.
     */
    match /users/{userId}/{subcollection}/{document=**} {
        allow read, write: if request.auth.uid == userId;
    }

    /**
     * @description Controls access to group documents.
     */
    match /groups/{groupId} {
        allow get: if isGroupMember(groupId);
        allow create: if isSignedIn();
        allow update: if isSignedIn() && request.auth.uid in resource.data.members;
        allow delete: if isSignedIn() && resource.data.createdBy == request.auth.uid;
    }
    
    match /groups {
        allow list: if isSignedIn();
    }

    /**
     * @description Controls access to shared expense documents within a group.
     */
    match /groups/{groupId}/sharedExpenses/{expenseId} {
        allow get, create: if isGroupMember(groupId) && request.resource.data.groupId == groupId;
        allow update, delete: if isGroupMember(groupId) && resource.data.paidBy == request.auth.uid;
    }
    
    match /groups/{groupId}/sharedExpenses {
        allow list: if isGroupMember(groupId);
    }

    /**
     * @description Controls access to debt documents.
     */
    match /debts/{debtId} {
        allow get: if isSignedIn() && (request.auth.uid == resource.data.fromUserId || request.auth.uid == resource.data.toUserId || request.auth.uid == resource.data.createdBy);
        allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
        allow update, delete: if isSignedIn() && resource.data.createdBy == request.auth.uid;
    }

    match /debts {
        allow list: if isSignedIn();
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isGroupMember(groupId) {
        return request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members;
    }
  }
}
