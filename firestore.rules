/**
 * @file Firestore Security Rules for FinanceFlow
 * @description This ruleset enforces a strict user-ownership model for personal financial data,
 * and shared access for group expenses. It prioritizes security and data isolation
 * while allowing for flexible data shapes during prototyping.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data, accessible only by the user themselves.
 * - /users/{userId}/incomes/{incomeId}: Stores income entries, accessible only by the user.
 * - /users/{userId}/expenses/{expenseId}: Stores expense entries, accessible only by the user.
 * - /users/{userId}/categories/{categoryId}: Stores user-defined categories, accessible only by the user.
 * - /users/{userId}/budgets/{budgetId}: Stores budget information, accessible only by the user.
 * - /groups/{groupId}: Stores group information. Write access is restricted to group members.
 * - /groups/{groupId}/sharedExpenses/{expenseId}: Stores shared expenses for a group. Write access is restricted to group members.
 * - /debts/{debtId}: Stores debt information between two users. Write access is restricted to debt creator.
 *
 * Key Security Decisions:
 * - User listing is disallowed to protect privacy.
 * - Default security posture for ambiguous relationships is strict owner-only access.
 *
 * Denormalization for Authorization:
 * - Group and SharedExpense documents are structured to include member lists/maps directly within the document,
 *   allowing for efficient authorization checks without additional database reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the document.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    /**
     * @description Rule for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile.
     *   Request: { "auth": { "uid": "user123" }, "method": "create", "path": "/databases/(default)/documents/users/user123", "resource": { "data": { "email": "test@example.com", "createdAt": "2024-01-01T00:00:00Z" } } }
     * @deny (update) User with ID 'user456' cannot update user profile 'user123'.
     *   Request: { "auth": { "uid": "user456" }, "method": "update", "path": "/databases/(default)/documents/users/user123", "resource": { "data": { "email": "new@example.com" } } }
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not permitted for privacy.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for the /users/{userId}/incomes/{incomeId} collection.
     * @path /users/{userId}/incomes/{incomeId}
     * @allow (create) User with ID 'user123' can create an income entry.
     *   Request: { "auth": { "uid": "user123" }, "method": "create", "path": "/databases/(default)/documents/users/user123/incomes/income1", "resource": { "data": { "userId": "user123", "amount": 1000, "date": "2024-01-05", "category": "Salary" } } }
     * @deny (update) User with ID 'user456' cannot update income entry 'income1' of user 'user123'.
     *   Request: { "auth": { "uid": "user456" }, "method": "update", "path": "/databases/(default)/documents/users/user123/incomes/income1", "resource": { "data": { "amount": 1200 } } }
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId}/incomes/{incomeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Rule for the /users/{userId}/expenses/{expenseId} collection.
     * @path /users/{userId}/expenses/{expenseId}
     * @allow (create) User with ID 'user123' can create an expense entry.
     *   Request: { "auth": { "uid": "user123" }, "method": "create", "path": "/databases/(default)/documents/users/user123/expenses/expense1", "resource": { "data": { "userId": "user123", "amount": 50, "date": "2024-01-05", "category": "Food" } } }
     * @deny (update) User with ID 'user456' cannot update expense entry 'expense1' of user 'user123'.
     *   Request: { "auth": { "uid": "user456" }, "method": "update", "path": "/databases/(default)/documents/users/user123/expenses/expense1", "resource": { "data": { "amount": 60 } } }
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId}/expenses/{expenseId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Rule for the /users/{userId}/categories/{categoryId} collection.
     * @path /users/{userId}/categories/{categoryId}
     * @allow (create) User with ID 'user123' can create a category.
     *   Request: { "auth": { "uid": "user123" }, "method": "create", "path": "/databases/(default)/documents/users/user123/categories/category1", "resource": { "data": { "userId": "user123", "name": "Food", "icon": "utensils", "type": "expense" } } }
     * @deny (update) User with ID 'user456' cannot update category 'category1' of user 'user123'.
     *   Request: { "auth": { "uid": "user456" }, "method": "update", "path": "/databases/(default)/documents/users/user123/categories/category1", "resource": { "data": { "name": "Groceries" } } }
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId}/categories/{categoryId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Rule for the /users/{userId}/budgets/{budgetId} collection.
     * @path /users/{userId}/budgets/{budgetId}
     * @allow (create) User with ID 'user123' can create a budget.
     *   Request: { "auth": { "uid": "user123" }, "method": "create", "path": "/databases/(default)/documents/users/user123/budgets/budget1", "resource": { "data": { "userId": "user123", "amount": 200, "month": "2024-01" } } }
     * @deny (update) User with ID 'user456' cannot update budget 'budget1' of user 'user123'.
     *   Request: { "auth": { "uid": "user456" }, "method": "update", "path": "/databases/(default)/documents/users/user123/budgets/budget1", "resource": { "data": { "amount": 250 } } }
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId}/budgets/{budgetId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Rule for the /groups/{groupId} collection.
     * @path /groups/{groupId}
     * @allow (create) User with ID 'user123' can create a group if they are the creator.
     *   Request: { "auth": { "uid": "user123" }, "method": "create", "path": "/databases/(default)/documents/groups/group1", "resource": { "data": { "name": "Family", "members": ["user123"], "createdBy": "user123", "createdAt": "2024-01-05" } } }
     * @deny (update) User with ID 'user456' cannot update group 'group1' if they are not a member.
     *   Request: { "auth": { "uid": "user456" }, "method": "update", "path": "/databases/(default)/documents/groups/group1", "resource": { "data": { "name": "Friends" } } }
     * @principle Enforces shared access based on group membership.
     */
    match /groups/{groupId} {
        allow get: if resource.data.members.hasAny([request.auth.uid]);
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
        allow update: if isSignedIn() && resource != null && resource.data.members.hasAny([request.auth.uid]);
        allow delete: if isSignedIn() && resource != null && resource.data.createdBy == request.auth.uid;
    }

    /**
     * @description Rule for the /groups/{groupId}/sharedExpenses/{expenseId} collection.
     * @path /groups/{groupId}/sharedExpenses/{expenseId}
     * @allow (create) User with ID 'user123' can create a shared expense if they are a member of the group.
     *   Request: { "auth": { "uid": "user123" }, "method": "create", "path": "/databases/(default)/documents/groups/group1/sharedExpenses/expense1", "resource": { "data": { "groupId": "group1", "description": "Dinner", "amount": 100, "paidBy": "user123", "date": "2024-01-05", "splits": [{ "userId": "user123", "amount": 50 }, { "userId": "user456", "amount": 50 }] } } }
     * @deny (update) User with ID 'user456' cannot update shared expense 'expense1' of group 'group1' if they are not a member.
     *   Request: { "auth": { "uid": "user456" }, "method": "update", "path": "/databases/(default)/documents/groups/group1/sharedExpenses/expense1", "resource": { "data": { "amount": 120 } } }
     * @principle Enforces shared access based on group membership.
     */
    match /groups/{groupId}/sharedExpenses/{expenseId} {
        allow get: if get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
        allow list: if get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
        allow create: if isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
        allow update: if isSignedIn() && resource != null && get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
        allow delete: if isSignedIn() && resource != null && get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
    }

    /**
     * @description Rule for the /debts/{debtId} collection.
     * @path /debts/{debtId}
     * @allow (create) User with ID 'user123' can create a debt if they are the creator.
     *   Request: { "auth": { "uid": "user123" }, "method": "create", "path": "/databases/(default)/documents/debts/debt1", "resource": { "data": { "fromUserId": "user123", "toUserId": "user456", "amount": 50, "description": "Lunch", "settled": false, "createdBy": "user123" } } }
     * @deny (update) User with ID 'user456' cannot update debt 'debt1' if they are not the creator.
     *   Request: { "auth": { "uid": "user456" }, "method": "update", "path": "/databases/(default)/documents/debts/debt1", "resource": { "data": { "settled": true } } }
     * @principle Enforces creator-only write access for debts.
     */
    match /debts/{debtId} {
        allow get: if true;
        allow list: if isSignedIn();
        allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
        allow update: if isSignedIn() && resource != null && request.resource.data.createdBy == request.auth.uid;
        allow delete: if isSignedIn() && resource != null && request.resource.data.createdBy == request.auth.uid;
    }
  }
}