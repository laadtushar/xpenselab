/**
 * @fileoverview Firestore Security Rules for FinanceFlow.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal financial data,
 * and shared access for group expenses.  It prioritizes data privacy and ensures
 * that users can only access their own information, unless explicitly shared through
 * group memberships.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only by the user themselves.
 * - /users/{userId}/incomes/{incomeId}: Income entries owned by the user.
 * - /users/{userId}/expenses/{expenseId}: Expense entries owned by the user.
 * - /users/{userId}/categories/{categoryId}: User-defined categories.
 * - /users/{userId}/budgets/{budgetId}: User-defined budgets.
 * - /groups/{groupId}: Group information, including member list.
 * - /groups/{groupId}/sharedExpenses/{expenseId}: Expenses shared within a group.
 * - /debts/{debtId}: Debts between two users.
 *
 * Key Security Decisions:
 * - Users can only read, create, update, and delete their own profile data.
 * - Income, expenses, categories, and budgets are strictly user-owned.
 * - Group data is accessible to group members.
 * - Listing of users is disallowed for privacy.
 * - The rules explicitly deny any operation that is not explicitly allowed.
 *
 * Denormalization for Authorization:
 * - Group membership is stored directly within the /groups/{groupId} document
 *   using the `members` field (array of user IDs). This avoids the need for
 *   complex queries or separate membership collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data.
     * @path /users/{userId}
     * @allow (create) User with matching UID can create their profile.
     * @allow (get, update, delete) User with matching UID can access and modify their profile.
     * @deny (list) Listing users is not allowed.
     * @deny (create) User cannot create a profile with a mismatched UID.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to income entries for a specific user.
     * @path /users/{userId}/incomes/{incomeId}
     * @allow (create, get, update, delete, list) User with matching UID can manage their income entries.
     * @deny Request with mismatched UID will be rejected.
     * @principle Enforces user-ownership for income data.
     */
    match /users/{userId}/incomes/{incomeId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to expense entries for a specific user.
     * @path /users/{userId}/expenses/{expenseId}
     * @allow (create, get, update, delete, list) User with matching UID can manage their expense entries.
     * @deny Request with mismatched UID will be rejected.
     * @principle Enforces user-ownership for expense data.
     */
    match /users/{userId}/expenses/{expenseId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to user-specific expense categories.
     * @path /users/{userId}/categories/{categoryId}
     * @allow (create, get, update, delete, list) User with matching UID can manage their categories.
     * @deny Request with mismatched UID will be rejected.
     * @principle Enforces user-ownership for expense categories.
     */
    match /users/{userId}/categories/{categoryId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to budget entries for a specific user.
     * @path /users/{userId}/budgets/{budgetId}
     * @allow (create, get, update, delete, list) User with matching UID can manage their budget entries.
     * @deny Request with mismatched UID will be rejected.
     * @principle Enforces user-ownership for budget data.
     */
    match /users/{userId}/budgets/{budgetId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to group information.
     * @path /groups/{groupId}
     * @allow (create) Any signed-in user can create a group. The `createdBy` field must match the user's UID.
     * @allow (get, list) Any member of the group can read the group information.
     * @allow (update, delete) Only the group creator can update or delete the group.
     * @deny Requests from users who are not members of the group.
     * @principle Enforces shared access for group members.
     */
    match /groups/{groupId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isGroupMember(groupId) {
          return isSignedIn() && request.auth.uid in resource.data.members;
      }
      function isGroupCreator() {
          return isSignedIn() && request.auth.uid == resource.data.createdBy;
      }
      function isExistingGroupMember(groupId) {
        return isGroupMember(groupId) && exists(resource);
      }
      function isExistingGroupCreator() {
        return isGroupCreator() && exists(resource);
      }
      allow get: if isExistingGroupMember(groupId);
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isExistingGroupCreator();
      allow delete: if isExistingGroupCreator();
    }

    /**
     * @description Controls access to shared expenses within a group.
     * @path /groups/{groupId}/sharedExpenses/{expenseId}
     * @allow (create, get, list) Any member of the group can manage shared expenses.
     * @allow (update, delete) Only the user who created shared expense can update or delete it.
     * @deny Requests from users who are not members of the group.
     * @principle Enforces shared access for group expenses.
     */
    match /groups/{groupId}/sharedExpenses/{expenseId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function getGroup(groupId) {
        return get(/databases/$(database)/documents/groups/$(groupId)).data;
      }
      function isGroupMember(groupId) {
        return isSignedIn() && request.auth.uid in getGroup(groupId).members;
      }
      function isExpenseCreator() {
        return request.auth.uid == resource.data.createdBy;
      }
      function isExistingGroupMember(groupId) {
        return isGroupMember(groupId) && exists(/databases/$(database)/documents/groups/$(groupId));
      }
      function isExistingExpenseCreator() {
        return isExpenseCreator() && exists(resource);
      }
      allow get: if isExistingGroupMember(groupId);
      allow list: if isGroupMember(groupId);
      allow create: if isGroupMember(groupId);
      allow update: if isExistingExpenseCreator();
      allow delete: if isExistingExpenseCreator();
    }
    /**
     * @description Controls access to debt information between two users.
     * @path /debts/{debtId}
     * @allow (create) Any signed-in user can create a debt record. The `createdBy` field must match the user's UID.
     * @allow (get) Only the user who is owed money (`toUserId`) or the user who owes money (`fromUserId`) can read the debt information.
     * @allow (list) Listing debts is disallowed for privacy.
     * @allow (update, delete) No one can update or delete debt record.
     * @deny Requests from unauthorized users.
     */
    match /debts/{debtId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isRelatedUser() {
        return isSignedIn() && (resource.data.toUserId == request.auth.uid || resource.data.fromUserId == request.auth.uid);
      }
      allow get: if isRelatedUser();
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }
  }
}