/**
 * @fileoverview Firestore Security Rules for FinanceFlow application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal financial data
 * and a shared-access model for group-related data. It prioritizes simplicity
 * and security by leveraging path-based authorization and avoiding `get()` calls
 * wherever possible. The rules explicitly deny any ambiguous or unintended access.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data, accessible only by the user.
 * - /users/{userId}/incomes/{incomeId}: Stores income entries, accessible only by the user.
 * - /users/{userId}/expenses/{expenseId}: Stores expense entries, accessible only by the user.
 * - /users/{userId}/categories/{categoryId}: Stores expense categories, accessible only by the user.
 * - /users/{userId}/budgets/{budgetId}: Stores budget entries, accessible only by the user.
 * - /groups/{groupId}: Stores group information, accessible by group members.
 * - /groups/{groupId}/sharedExpenses/{sharedExpenseId}: Stores shared expenses, accessible by group members.
 * - /debts/{debtId}: Stores debt information between two users, accessible by the two users involved.
 *
 * Key Security Decisions:
 * - User data is strictly segregated and accessible only by the authenticated user.
 * - Group data is accessible to members of the group.
 * - Read access is explicitly controlled.
 * - Data validation is relaxed to allow for rapid prototyping but critical authorization fields are validated.
 *
 * Denormalization for Authorization:
 * - The `userId` is embedded within documents in the `/users/{userId}/...` subcollections,
 *   allowing rules to quickly verify ownership based on the path.
 * - The `members` array on `/groups/{groupId}` documents allows rules to check group membership without `get()` calls.
 *
 * Structural Segregation:
 * - User-specific data (incomes, expenses, etc.) is stored under the `/users/{userId}` path,
 *   while group-related data is stored in the top-level `/groups` collection,
 *   allowing for clear separation of access control concerns.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces access control for user profiles. Only the authenticated user can access their own profile.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their profile: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' reads their profile: request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' updates their profile: request.auth.uid == 'user123'
     * @allow (delete) User with ID 'user123' deletes their profile: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user123' attempts to create profile for 'user456': request.auth.uid != 'user456'
     * @principle Enforces document ownership for writes and reads.
     */
    match /users/{userId} {
      allow create: if isSignedIn() && isOwner(userId);
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user-specific income entries. Only the authenticated user can access their own income data.
     * @path /users/{userId}/incomes/{incomeId}
     * @allow (create) User with ID 'user123' creates an income entry: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' reads an income entry: request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' updates an income entry: request.auth.uid == 'user123'
     * @allow (delete) User with ID 'user123' deletes an income entry: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user123' attempts to create an income entry for 'user456': request.auth.uid != 'user456'
     * @principle Enforces document ownership for writes and reads on subcollections.
     */
    match /users/{userId}/incomes/{incomeId} {
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId) && resource.data.userId == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user-specific expense entries. Only the authenticated user can access their own expense data.
     * @path /users/{userId}/expenses/{expenseId}
     * @allow (create) User with ID 'user123' creates an expense entry: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' reads an expense entry: request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' updates an expense entry: request.auth.uid == 'user123'
     * @allow (delete) User with ID 'user123' deletes an expense entry: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user123' attempts to create an expense entry for 'user456': request.auth.uid != 'user456'
     * @principle Enforces document ownership for writes and reads on subcollections.
     */
    match /users/{userId}/expenses/{expenseId} {
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId) && resource.data.userId == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user-specific expense categories. Only the authenticated user can access their own categories.
     * @path /users/{userId}/categories/{categoryId}
     * @allow (create) User with ID 'user123' creates a category: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' reads a category: request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' updates a category: request.auth.uid == 'user123'
     * @allow (delete) User with ID 'user123' deletes a category: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user123' attempts to create a category for 'user456': request.auth.uid != 'user456'
     * @principle Enforces document ownership for writes and reads on subcollections.
     */
    match /users/{userId}/categories/{categoryId} {
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId) && resource.data.userId == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user-specific budget entries. Only the authenticated user can access their own budget data.
     * @path /users/{userId}/budgets/{budgetId}
     * @allow (create) User with ID 'user123' creates a budget entry: request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' reads a budget entry: request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' updates a budget entry: request.auth.uid == 'user123'
     * @allow (delete) User with ID 'user123' deletes a budget entry: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user123' attempts to create a budget entry for 'user456': request.auth.uid != 'user456'
     * @principle Enforces document ownership for writes and reads on subcollections.
     */
    match /users/{userId}/budgets/{budgetId} {
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId) && resource.data.userId == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for groups.  Only members of the group can access the group document.
     * @path /groups/{groupId}
     * @allow (create) User with ID 'user123' creates a group: request.auth.uid is in request.resource.data.members
     * @allow (get) User with ID 'user123' reads a group they are a member of: request.auth.uid is in resource.data.members
     * @allow (update) User with ID 'user123' updates a group they are a member of: request.auth.uid is in resource.data.members
     * @allow (delete) User with ID 'user123' deletes a group they created and are a member of: request.auth.uid is in resource.data.members
     * @deny (create) User with ID 'user123' attempts to create a group without being a member: request.auth.uid is not in request.resource.data.members
     * @principle Enforces shared access based on group membership.
     */
    match /groups/{groupId} {
      allow create: if isSignedIn() && request.resource.data.members.hasAny([request.auth.uid]);
      allow get: if isSignedIn() && resource.data.members.hasAny([request.auth.uid]);
      allow list: if false;
      allow update: if isSignedIn() && resource.data.members.hasAny([request.auth.uid]);
      allow delete: if isSignedIn() && resource.data.members.hasAny([request.auth.uid]);
    }

    /**
     * @description Enforces access control for shared expenses within a group.  Only members of the group can access the shared expenses.
     * @path /groups/{groupId}/sharedExpenses/{sharedExpenseId}
     * @allow (create) User with ID 'user123' creates a shared expense in a group they are a member of: get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid])
     * @allow (get) User with ID 'user123' reads a shared expense in a group they are a member of: get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid])
     * @allow (update) User with ID 'user123' updates a shared expense in a group they are a member of: get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid])
     * @allow (delete) User with ID 'user123' deletes a shared expense in a group they are a member of: get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid])
     * @deny (create) User with ID 'user123' attempts to create a shared expense in a group they are not a member of: get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]) == false
     * @principle Enforces shared access based on group membership.  Requires a `get()` call to verify group membership.
     */
    match /groups/{groupId}/sharedExpenses/{sharedExpenseId} {
      allow create: if isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
      allow get: if isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
      allow list: if isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
      allow update: if isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
    }

    /**
     * @description Enforces access control for debts. Only the two users involved in the debt can access the debt document.
     * @path /debts/{debtId}
     * @allow (create) User with ID 'user123' creates a debt: request.auth.uid == request.resource.data.fromUserId || request.auth.uid == request.resource.data.toUserId
     * @allow (get) User with ID 'user123' reads a debt they are involved in: request.auth.uid == resource.data.fromUserId || request.auth.uid == resource.data.toUserId
     * @allow (update) User with ID 'user123' updates a debt they are involved in: request.auth.uid == resource.data.fromUserId || request.auth.uid == resource.data.toUserId
     * @allow (delete) User with ID 'user123' deletes a debt they are involved in: request.auth.uid == resource.data.fromUserId || request.auth.uid == resource.data.toUserId
     * @deny (create) User with ID 'user123' attempts to create a debt they are not involved in: request.auth.uid != request.resource.data.fromUserId && request.auth.uid != request.resource.data.toUserId
     * @principle Enforces shared access based on user involvement in the debt.
     */
    match /debts/{debtId} {
      allow create: if isSignedIn() && (request.auth.uid == request.resource.data.fromUserId || request.auth.uid == request.resource.data.toUserId);
      allow get: if isSignedIn() && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);
      allow list: if false;
      allow update: if isSignedIn() && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);
      allow delete: if isSignedIn() && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isSignedIn() && isOwner(userId) && resource != null;
    }
  }
}